export { swiss as theme } from 'mdx-deck/themes'
import { Split } from 'mdx-deck/layouts'
import { CodeSurfer } from "mdx-deck-code-surfer"

graphql-client

```notes
- name
- first time talking on a meetup
- I want to talk about a small library I started early June
```

---

### Why?

<video
    autoPlay
    loop
    src="./assets/cat-box.mp4"
/>

<div>
no graphql client in Rust
</div>

```notes
- If it fits, I sits
- I like GraphQL
- I had ideas about GraphQL servers
- Noticed there is no client in Rust
```

---

### pure Rust (?)

<!-- no js dependencies -->
<!-- insert line counts with json here -->

```
------------------------------------
 Language                    Lines
------------------------------------
 JSON                        47193
 Rust                         4782
------------------------------------
```

<small>counted with <a href="https://github.com/Aaronepower/tokei">tokei</a></small>

```notes
- impostor?
```

---

### Wait, what?

<img src="./assets/songe-of-graphql.png" />

```notes
- Let's backtrack a bit
- Let's talk about GraphQL
- Who has worked or is familiar with GraphQL?
```


---

<img
    src='./assets/GraphQL_Logo.svg.png'
    height="150"
/>

- A query language and a specification for building APIs
- All the data you need for a view in one request (client-centric)
- Developed at Facebook, open sourced in 2015
- Very rich, growing ecosystem, fast adoption (Github, Shopify, Facebook, Twitter...)

```notes
- Technology for building APIs, with clients requesting data from a servers
- Spec defining two languages, a type system and the behaviour of servers
- One query -> query a graph objecst and fields
- Client-centric
  - Fetch exactly what you need
  - Nesting (post -> comment -> author -> posts)
- Makes it easy to evolve your API
- Transport agnostic, but most of the time JSON over HTTP
```

---

Example


![](./assets/github-graphiql-example.png)


```notes
- You get what you ask for (client-centric)
- Nesting -> you query an object tree
```

---

## Why you want a client library

- Correctness
- Take advantage of behaviour defined in the spec (error handling...)
- Caching
- *Strong typing*

```notes
- It's easy to make wrong requests
- That's a small part of the library
- No caching yet
- Strong typing is what I want to talk about
```

---

## How it works - introspection

- GraphQL is typed
- Introspection is defined by the spec and meant to be used for code generation
- With a GraphQL query and the schema, we can generate a struct for the response shape

```notes
- GraphQL has a type system - defined by the spec so it's shared between all server implementations
- You can ask a server, at runtime, what API it exposes (also in the spec)
- It returns a structured response you can generate code for a client from - think mini-SDK.
- Why you need both query and schema (selection)
```

---

<CodeSurfer
  notes="Our API - an address book"
  lang="graphql"
  code={require('!raw-loader!./schema.graphql')}
  showNumbers={true}
  steps={[
    { range: [1, 3], notes: 'We first define the root field: QueryRoot' },
    { range: [5, 9], notes: 'The fields can take arguments at any depth' },
    { lines: [6], notes: "Let's start here" },
    { range: [18, 22], notes: "Object types are like structs" },
  ]}
/>

```notes
- Explain query, mutations, subscriptions
```

---


<CodeSurfer
  lang="graphql"
  code={require('!raw-loader!./simple_query.graphql')}
  showNumbers={true}
  steps={[
    { range: [0, 21], notes: 'Request-response' },
    { tokens: { 3: [2] }, notes: 'name the query'},
    { tokens: { 3: [3, 4, 5, 6, 7, 8] }, notes: 'declare variables (parameters)' },
    { range: [4, 8], notes: 'select what we want'},
    { range: [11, 21], notes: 'get what we asked for'},
    { range: [23, 35], notes: 'put it in convenient Rust data structures' },
  ]}
/>

---

<CodeSurfer
  lang="rust"
  notes="how we would use it"
  code={`
fn get_birthday_from_api(name: String) -> Result<Option<Date>, failure::Error> {
  let response = make_request(name)?;
  response.data.and_then(|data| data.person).and_then(|person| person.birthday)
}
  `}
  showNumbers={true}
/>

---

<CodeSurfer
  notes="Remember our api"
  lang="graphql"
  code={require('!raw-loader!./schema.graphql')}
  showNumbers={true}
  steps={[
    { range: [5, 9], notes: 'Our root fields' },
    { lines: [6], notes: "we just did this" },
    { lines: [7], notes: "let's do that" },
    { lines: [11], notes: "unions are a bit like untagged unions in Rust" },
    { range: [18, 36], notes: "any one of these types" },
  ]}
/>

---

<CodeSurfer
  lang="graphql"
  code={require('!raw-loader!./union_query.graphql')}
  showNumbers
  steps={[
    { range: [0, 26], notes: 'Request-response' },
    { range: [1, 15], notes: 'the query looks different' },
    { range: [6, 13], notes: 'we have to discriminate which fields we select by type'},
    { range: [5, 5], notes: 'we can ask the name of the type we get (introspection)' },
    { range: [17, 26], notes: 'we get what we asked for'},
    { range: [28, 33], notes: 'put it in convenient Rust data structures' },
    { range: [35, 41], notes: 'we have a tag, serde can give us an enum' },
    { range: [43, 51], notes: 'selections on objects work like before' },
  ]}
/>

---

<CodeSurfer
  lang="rust"
  notes="how we would use it"
  code={`
fn get_birthday_from_api() -> Result<(), failure::Error> {
  let response = make_request()?;
  response.data
    .and_then(|data| data.entry)
    .map(|entry| {
      match entry {
        EntryByIdEntry::Person(person) => send_birthday_card(person),
        EntryByIdEntry::Organization(organization) =>
            send_birthday_card_to_members(organization),
        EntryByIdEntry::DeletedEntry =>
            return Err(format_err!("The entry was deleted")),
      }
    });
  Ok(())
}
  `}
  showNumbers={true}
  steps={[
    { range: [7, 13] },
  ]}
/>

---

Query

```graphql
{
  search(text: "an") {
    ... on Human {
      name
      height
    }
    ... on Droid {
      name
      primaryFunction
    }
    ... on Starship {
      name
      length
    }
  }
}
```

---

Response (JSON)

```graphql
{
  "data": {
    "search": [
      {
        "name": "Han Solo",
        "height": 1.8
      },
      {
        "name": "Leia Organa",
        "height": 1.5
      },
      {
        "name": "TIE Advanced x1",
        "length": 9.2
      }
    ]
  }
}
```

---

A new challenger appears!

```graphql
interface Character {
  id: ID!
  name: String!
  friends: [Character]
  appearsIn: [Episode]!
}
```

---

```graphql
type Human implements Character {
  id: ID!
  name: String!
  friends: [Character]
  appearsIn: [Episode]!
  starships: [Starship]
  totalCredits: Int
}

type Droid implements Character {
  id: ID!
  name: String!
  friends: [Character]
  appearsIn: [Episode]!
  primaryFunction: String
}
```

---

```graphql
query HeroForEpisode($ep: Episode!) {
  hero(episode: $ep) {
    name
    ... on Droid {
      primaryFunction
    }
  }
}
```

---

```graphql
{
  "data": {
    "hero": {
      "name": "R2-D2",
      "primaryFunction": "Astromech"
    }
  }
}
```

---

### This is all very javascripty


```notes
- A lot of things were easy (nullability, mapping the primitive types, custom scalars)
- Challenge for the library: map that to nice Rust data structures
```

---

Interlude: what's the API?


```rust
#[derive(GraphQLQuery)]
#[graphql(
    schema_path = "src/graphql/schema.json",
    query_path = "src/graphql/queries/my_query.graphql",
)]
pub struct MyQuery

```

...

```rust
    // this is the important line
    let request_body = MyQuery::build_query(variables);

    let client = reqwest::Client::new();
    let mut res = client.post("/graphql").json(&request_body).send()?;
    let response_body: Response<my_query::ResponseData> = res.json()?;
```

```notes
- Build script and CLI codegen are WIP
```

---

```graphql
query MyQuery($page: Int!) {
    contacts(page: $page) {
        __typename
        name
        ... on Person {
            birthday
        }
        ... on Organization {
            industry
            members(minimumAge: 40) {
                birthday
                name
            }
        }
    }
}
```

```notes
- Even for a simple query, it's not obvious
- We have Person twice, with different fields
- Not options, that would not be nice
- We have to generate two Person structs
- Solution: paths in names
- Lots of small interesting problems like thiss
```

---

### serde

---

```graphql
{
  search(text: "an") {
    ... on Human {
      name
      height
    }
    ... on Droid {
      name
      primaryFunction
    }
    ... on Starship {
      name
      length
    }
  }
}
```

```notes
- remember the query with an union
```

---

```rust
// union SearchResult = Human | Droid | Starship

#[derive(Deserialize)]
#[serde(tag = "__typename")]
enum Search {
  Human(SearchOnHuman),
  Droid(SearchOnDroid),
  Starship(SearchOnStarship),
}
```

<small>See <a href="https://serde.rs/enum-representations.html">enum representations</a> in the serde docs</small>


---

```graphql
query MyQuery {
  search(searchTerm: "Tatooine") {
    ...onHuman {
      name
    }
    ...onDroid {
      model
    }
    ...onStarship {
      engine { name }
    }
  }
}

```

```notes
- You _have_to include __typename
- And now for something completely different: interfaces
```

---

Interfaces

```graphql
query HeroQuery {
  hero(episode: JEDI) { # Character
    __typename # will return the concrete type
    name # part of Character
    ...on Human {
      hairColor
    }
  }
}
```

```notes
- Remember: this is what we write
```

---

```json
{
  "data": {
    "hero": {
      "__typename": "Human",
      "name": "Obi-Wan Kenobi",
      "hairColor": "WHITE"
    }
  }
}
```


```notes
- This is what we get
- We have the type! we can statically know which fields we will get.
```


---

```rust

#[derive(Deserialize)]
struct MyQueryHero { // Character
  typename: String,
  // common fields
  name: String,
  #[serde(flatten)]
  on: MyQueryHeroOn,
}

#[derive(Deserialize)]
#[serde(tag = "__typename")]
enum MyQueryHeroOn {
  Human(MyQueryHeroOnHuman),
  Droid,
  Starship,
}
```

```notes
- 'member
```

---

### Question to the audience

<video
    autoPlay
    loop
    src="./assets/intermission.mp4"
/>

---

if a GraphQL query wore pants...

---

would it wear them like this

```rust
fn call<Q>(
    &self,
    variables: &Q::Variables
) -> Future<GraphQLQueryResult>
where Q: GraphQLQuery
```
...
```rust

let response = await!(client.call::<RepositoriesIndex>(&variables));
```

---

or like this?

```rust
fn call<Q>(
    &self,
    query: Q,
    variables: &Q::Variables
) -> Future<GraphQLQueryResult>
where Q: GraphQLQuery
```
...

```rust
let response = await!(client.call(RepositoriesIndex, &variables));

```

---

### Learnings

---


Contributors come at you fast and when you are least prepared.

![](./assets/issue_screenshot_1.png)

```notes
- Thought it was ready - wrong
- Underestimated the work
```

---

export default Split


<img src="./assets/issue_screenshot_2.png" />

<video
  autoPlay
  loop
  src="./assets/bubz.mp4"
/>


---

### Ecosystem

<video
    autoPlay
    loop
    src="./assets/ecosystem_synergy.mp4"
/>

<div>
    <small>cool crates</small>
</div>

```notes
- We have a really awesome ecosystem of basic building blocks like serde
- We can build higher-level libraries on top
- In graphql, graphql-parser
```

---

### Error handling - failure

<video
    autoPlay
    loop
    src="./assets/corgi-failure.mp4"
/>


---

### Macros - Cargo expand

---

### Dependencies - cargo-edit

<video
    autoPlay
    loop
    src="./assets/cargo-edit.mp4"
/>

---

### Cargo tree

---

### Future

- clients everywhere!
- normalized cache shared between implementations
- live updates with subscriptions
- build script, CLI and possibly proc macro-based codegen workflows
- codegen as an npm package
- better query validation
- friendlier error messages
- ...

---

<small>halp</small>


---

### Naming

<video
    autoPlay
    loop
    src="./assets/naming.mp4"
/>

---

### Documentation management

<div>
<img src="./assets/ghostbusters_library_1.gif" />
<img src="./assets/ghostbusters_library_2.gif" />
</div>

<!-- ghostbusters opening scene here -->

---

### CLI and build script APIs

```notes
- people with graphql experience: what do you think?
```

---

### Hacktoberfest

---

### Keep in touch

- graphql-client: https://github.com/tomhoule/graphql-client
- mastodon: [@vache_a_lemmes@eldritch.cafe](https://eldritch.cafe/web/accounts/30706)
- twitter: [@_tomhoule](https://twitter.com/_tomhoule)

---

### Links


- cargo-release: https://github.com/meh
- GraphQL guide: https://graphql.org
- [Why you might want a GraphQL client](https://blog.apollographql.com/why-you-might-want-a-graphql-client-e864050f789c)
